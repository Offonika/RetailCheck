# Архитектура «Чек-лист-бота»

Документ описывает техническую архитектуру MVP Telegram-бота для смен, основанного на материалах `docs/OnePage.md`, `docs/PRD.md` и `agents.md`. Цель — дать разработчикам и DevOps-специалистам опорную схему перед стартом имплементации.

## 1. Контекст и ограничения
- Клиент хочет минимальную инфраструктуру: Python-сервис на собственном Ubuntu-сервере без отдельной БД.
- Все данные живут в Google Sheets, это «единое место правды» для пользователей и интеграций.
- Пользователи: сотрудники магазинов (проходят чек-лист) и менеджеры (создают смены, принимают итог, запускают экспорт).
- KPI: время ответа шага ≤1.5 с, доступность 99%+ в рабочие часы, пакетная запись в Таблицу с ретраями.

## 2. Компоненты

| Компонент | Назначение | Библиотеки/инструменты | Примечания |
| --- | --- | --- | --- |
| Telegram Bot Service | Диалоговое ядро: шаги чек-листа, валидации, статусы Runs | Python 3.11, Aiogram/pyTelegramBotAPI, Pydantic, Redis (опционально для FSM) | Живёт в Docker/systemd; webhook режим |
| Webhook Gateway | Приём HTTPS и проксирование в бота | Nginx или Apache | Транслирует `https://bot.offonika.ru/checklist/webhook` на локальный порт |
| Google Sheets Sync | Чтение/запись данных чек-листов | Google Sheets API v4, google-auth | Пакетные batchUpdate, ретраи 429/5xx |
| Scheduler & Alerts | Крон/фоновые задачи для напоминаний и дельт | APScheduler/Celery beat + Redis | Работает как часть сервиса или отдельным воркером |
| Export Builder | Генерация листа `Export` по кнопке | Python job, Google Sheets API | Формирует плоские строки за день/неделю |
| Audit Logger | Протоколирование действий в лист `Audit` | Обёртка над Sheets Sync | Каждое важное событие → запись в Audit |

## 3. Топология развёртывания
1. **Ubuntu сервер клиента**. Размещается Docker-хост (или systemd unit) с Bot Service и Scheduler Worker.
2. **Nginx/Apache** на сервере принимает HTTPS (Let's Encrypt) и отправляет POST-запросы Telegram на `localhost:<bot_port>/webhook`.
3. **Telegram Bot API** взаимодействует по HTTPS → Nginx → Bot Service.
4. **Google Sheets API** доступен напрямую из Bot Service/Worker через сервисный аккаунт.
5. **Внутренние очереди (опционально Redis)** для FSM состояния, напоминаний, idempotency cache.

## 4. Основные потоки

### 4.1 Смена сотрудника (Runs)
1. Менеджер или крон создаёт запись Runs со статусом `in_progress` через кнопку «Создать смену».
2. Сотрудник получает кнопку «Начать смену» и переходит в сценарий: Bot Service считывает шаблон шагов (`Templates`, `TemplateSteps`).
3. На каждом шаге выполняется валидация (формат, диапазон, обязательность). При расхождении бот вычисляет `delta` и требует комментарий при |delta| ≥ порога.
4. Данные шагов пишутся в `RunSteps` пакетно после подтверждения шага (batched per n шагов или по завершению). Для фото хранится `telegram_file_id` в `Attachments`.
5. После шага «Итог» бот рассчитывает summary, обновляет `Runs.status = done`, записывает Audit и отправляет карточку менеджеру.

### 4.2 Напоминания/алерты
1. Scheduler каждые 15 мин проверяет расписание (11:00 / 16:00 / 19:00). Если у магазина есть обязательные шаги в `in_progress`, отправляет мягкое напоминание сотрудникам.
2. Когда шаг закрыт с дельтой ≥ порога, бот сразу шлёт уведомление менеджеру, а Scheduler ставит флаг, чтобы не дублировать уведомление.

### 4.3 Экспорт
1. Менеджер жмёт «Экспорт за день/неделю».
2. Export Builder читает Runs и RunSteps за период, нормализует строки (магазин, дата, статусы, суммы, фото-ссылки/ID) и записывает их в лист `Export`.
3. Audit Logger фиксирует операцию; бот отправляет ссылку на лист.

### 4.4 Возврат на доработку
1. Менеджер выбирает «Вернуть на доработку». Bot Service ставит `Runs.status = returned`, помечает проблемные `RunSteps.status = error`.
2. Сотруднику присылается список обязательных шагов для исправления; сценарий продолжается со второго прохода.

## 5. Технологический стек
- **Язык/рантайм:** Python 3.11+.
- **Фреймворк бота:** Aiogram 3 (async) или Telethon-like. Aiogram предпочтителен за FSM и middlewares.
- **Хранение состояния:** In-memory FSM с Redis backend (для горизонтального масштабирования и напоминаний).
- **Работа с Google Sheets:** `google-api-python-client`, `google-auth`, вспомогательные обёртки для batchUpdate.
- **Контейнеризация:** Docker + docker-compose (bot, worker, redis, nginx). Альтернатива — systemd units, если Docker нежелателен.
- **CI/CD:** GitHub Actions/GitLab CI (lint + tests + docker build) → rsync/docker pull на сервер клиента.

## 6. Конфигурация и безопасность
- Секреты Telegram Bot Token и Google Service Account JSON храним вне репозитория (Ansible vault, env vars, Secret Manager). В коде только пути/переменные окружения.
- Белый список пользователей и магазинов подтягивается из листов `Users` и `Shops`.
- Ограничиваем исходящий доступ сервера только к Telegram API и Google APIs.
- Логи чувствительных данных (суммы, комментарии) маскируем перед отправкой в общий лог.
- Для вебхука используем проверку `X-Telegram-Bot-Api-Secret-Token`, задавая значение в Telegram.

## 7. Нефункциональные требования и наблюдаемость
- **Производительность:** средний шаг ≤1.5 с; heavy-операции (загрузка фото, batch write) ≤5 с. Используем очереди для повторных попыток.
- **Надёжность:** retry policy (3 попытки, экспоненциальная задержка) при ошибках Google API; idempotency_key на каждой batch-записи.
- **Логи/мониторинг:** структурированные логи (JSON) → Loki/ELK; метрики (кол-во Runs, ошибок валидации, время обработки шага). Alerts при SLA нарушениях напоминаний.
- **Тестирование:** модульные тесты валидаторов, интеграционные тесты с mock Sheets API, e2e-скрипты через Telegram test bot.

## 8. TODO перед началом кодирования
1. Уточнить, будет ли Redis доступен; если нет — выбрать альтернативу для scheduler (system cron + postgres?).
2. Выбрать конкретную библиотеку бота (aiogram vs telebot) и зафиксировать в README.
3. Решить, используем ли Docker в проде или чистый systemd.
4. Подготовить сервисный аккаунт Google и расшарить Таблицу (см. `docs/DataModel.md`).
