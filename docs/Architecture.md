# Архитектура «Чек-лист-бота»

Документ описывает техническую архитектуру MVP Telegram-бота для смен, основанного на материалах `docs/OnePage.md`, `docs/PRD.md` и `agents.md`. Цель — дать разработчикам и DevOps-специалистам опорную схему перед стартом имплементации.

## 1. Контекст и ограничения
- Клиент хочет минимальную инфраструктуру: Python-сервис на собственном Ubuntu-сервере без отдельной БД.
- Все данные живут в Google Sheets, это «единое место правды» для пользователей и интеграций.
- Пользователи: сотрудники магазинов (опener/closer, проходят чек-лист) и менеджеры (контролируют run, при необходимости вручную создают смену, принимают итог, запускают экспорт).
- KPI: время ответа шага ≤1.5 с, доступность 99%+ в рабочие часы, пакетная запись в Таблицу с ретраями.

## 2. Компоненты

| Компонент | Назначение | Библиотеки/инструменты | Примечания |
| --- | --- | --- | --- |
| Telegram Bot Service | Диалоговое ядро: шаги чек-листа, валидации, статусы Runs | Python 3.11, Aiogram/pyTelegramBotAPI, Pydantic, Redis (опционально для FSM) | Живёт в Docker/systemd; webhook режим |
| Webhook Gateway | Приём HTTPS и проксирование в бота | Nginx или Apache | Транслирует `https://bot.offonika.ru/checklist/webhook` на локальный порт |
| Google Sheets Sync | Чтение/запись данных чек-листов | Google Sheets API v4, google-auth | Пакетные batchUpdate, ретраи 429/5xx |
| Scheduler & Alerts | Крон/фоновые задачи для напоминаний и дельт | APScheduler (см. `tools/reminder_scheduler.py`) + Redis | Работает как часть сервиса или отдельным воркером |
| Export Builder | Генерация листа `Export` по кнопке | Python job, Google Sheets API | Формирует плоские строки за день/неделю |
| Audit Logger | Протоколирование действий в лист `Audit` | Обёртка над Sheets Sync | Каждое важное событие → запись в Audit |

## 3. Топология развёртывания
1. **Ubuntu сервер клиента**. Размещается Docker-хост (или systemd unit) с Bot Service и Scheduler Worker.
2. **Nginx/Apache** на сервере принимает HTTPS (Let's Encrypt) и отправляет POST-запросы Telegram на `localhost:<bot_port>/webhook`.
3. **Telegram Bot API** взаимодействует по HTTPS → Nginx → Bot Service.
4. **Google Sheets API** доступен напрямую из Bot Service/Worker через сервисный аккаунт.
5. **Внутренние очереди (опционально Redis)** для FSM состояния, напоминаний, idempotency cache.

## 4. Основные потоки

### 4.1 Смена сотрудника (Runs)
1. Первый сотрудник, нажавший «Начать смену» (deep-link `?start=shop_<id>__open`), получает роль opener. Bot Service ставит Redis-lock `run:{shop_id}:{date}`, создаёт run со статусом `opened` (если его не было) и фиксирует `opener_user_id`.
2. Opener проходит шаблон «Открытие» (шаги загружаются по `run.template_phase_map["open"]`). По завершении run переходит в `in_progress`, фиксируются дельты/комментарии.
3. Ближе к закрытию сотрудник жмёт «Начать закрытие» (`?start=...__close`). Если `closer_user_id` пустой — назначается текущий пользователь, run остаётся `in_progress`.
4. В момент захвата локов (`lock:run:{shop}:{date}` и `:close`) сервис пишет лог «Lock ... acquired (ttl XXs)», что даёт возможность отслеживать зависшие локи (дополнительно есть CLI `tools/lock_monitor.py`).
5. Closer проходит шаблон `close` (и завершающий блок `finance`), которые бот подбирает по `template_phase_map`. После последнего шага run становится `ready_to_close`.
6. После шага «Итог» бот требует `/summary shop_id`: команда агрегирует шаги, проверяет Z-фото/комментарии, подсчитывает total Δ, вызывает `RunService.finalize_run`, пишет Audit `finish_close` и отправляет карточку менеджеру.
7. Менеджер может инициировать передачу роли («Передать открытие/закрытие»): Bot Service обновляет `opener_user_id` или `closer_user_id`, фиксируя Audit `handover_*`.

### 4.2 Напоминания/алерты
1. Scheduler каждые 5–10 минут пересчитывает два дефолтных слота для каждого магазина: `open_reminder = t_open − 15 мин`, `close_reminder = t_close − 30 мин` (учёт таймзоны). Пока роль не назначена, бот уведомляет всех сотрудников магазина и менеджеров; после назначения — только исполнителя роли + общий чат магазина. Поле `Shops.reminder_slots` в пилоте пустое и не влияет на расписание.
2. При |delta| ≥ порога бот сразу шлёт уведомление менеджеру и ставит флаг, чтобы не дублировать сообщение.

### 4.3 Экспорт
1. Менеджер жмёт «Экспорт за день/неделю».
2. Export Builder читает Runs и RunSteps за период, нормализует строки (магазин, дата, статусы, суммы, фото-ссылки/ID) и записывает их в лист `Export`.
3. Audit Logger фиксирует операцию; бот отправляет ссылку на лист.

### 4.4 Возврат на доработку
1. Менеджер выбирает «Вернуть на доработку». Bot Service ставит `Runs.status = returned`, помечает проблемные `RunSteps.status = error`.
2. Сотруднику присылается список обязательных шагов для исправления; сценарий продолжается со второго прохода.

## 5. Технологический стек
- **Язык/рантайм:** Python 3.11+.
- **Фреймворк бота:** Aiogram 3 (async) или Telethon-like. Aiogram предпочтителен за FSM и middlewares.
- **Хранение состояния:** In-memory FSM с Redis backend (для горизонтального масштабирования и напоминаний).
- **Работа с Google Sheets:** `google-api-python-client`, `google-auth`, вспомогательные обёртки для batchUpdate.
- **Контейнеризация:** Docker + docker-compose (bot, worker, redis, nginx). Альтернатива — systemd units, если Docker нежелателен.
- **CI/CD:** GitHub Actions/GitLab CI (lint + tests + docker build) → rsync/docker pull на сервер клиента.

## 6. Конфигурация и безопасность
- Секреты Telegram Bot Token и Google Service Account JSON храним вне репозитория (Ansible vault, env vars, Secret Manager). В коде только пути/переменные окружения.
- Белый список пользователей и магазинов подтягивается из листов `Users` и `Shops`.
- Ограничиваем исходящий доступ сервера только к Telegram API и Google APIs.
- Логи чувствительных данных (суммы, комментарии) маскируем перед отправкой в общий лог.
- Для вебхука используем проверку `X-Telegram-Bot-Api-Secret-Token`, задавая значение в Telegram.

## 7. Нефункциональные требования и наблюдаемость
- **Производительность:** средний шаг ≤1.5 с; heavy-операции (загрузка фото, batch write) ≤5 с. Используем очереди для повторных попыток.
- **Надёжность:** retry policy (3 попытки, экспоненциальная задержка) при ошибках Google API; idempotency_key на каждой batch-записи.
- **Логи/мониторинг:** структурированные логи (JSON) → Loki/ELK; метрики (кол-во Runs, ошибок валидации, время обработки шага). Alerts при SLA нарушениях напоминаний.
- **Тестирование:** модульные тесты валидаторов, интеграционные тесты с mock Sheets API, e2e-скрипты через Telegram test bot.

## 8. TODO перед началом кодирования
1. Уточнить, будет ли Redis доступен; если нет — выбрать альтернативу для scheduler (system cron + postgres?).
2. Выбрать конкретную библиотеку бота (aiogram vs telebot) и зафиксировать в README.
3. Решить, используем ли Docker в проде или чистый systemd.
4. Подготовить сервисный аккаунт Google и расшарить Таблицу (см. `docs/DataModel.md`).

## Deep-link из QR
- Ссылки на наклейках:  
  - `https://t.me/<bot>?start=shop_<id>__open`  
  - `https://t.me/<bot>?start=shop_<id>__close`
- В обработчике `/start` парсим payload, проставляем `shop_id` и целевое действие.

## Локи
- `lock:run:{shop_id}:{date}` — монополия на создание/получение единственного run (TTL 5–10 c).
- `lock:run:{shop_id}:{date}:open` и `:close` — мягкие локи от двойного клика при назначении роли.
